- CPU can directly access registers & main memory
- Protection of memory space by hardware
- base and limit registers defines logical address space loaded by OS
- MMU Memory Management Unit maps logical to physical addresses
- OS memory
	- Resident of OS
	- User processes

## Logical vs Physical Address space

- Logical
	- Generated by CPU
	- virtual address allows programmers to use memory without worrying about the physical location
	- 
- Physical
	- address seen by memory unit (RAM)
- Isolation  & Security, Abstraction, portability, efficient memory utilization

## Swapping
- Process swapped temporarily out of memory (RAM) into backing store (fast disk large enough to accommodate copies like SSD)
- Allows system to run with more memory than it actually is
- We will see this in Virtual Memory

## Contiguous Memory Allocation
- Allocating a single continuous memory block to a process as like 1 large chunk

### Issues - Fragmentation
- **External Fragmentation**
	- Free memory blocks split into small physical memory making it harder to allocate as 1 big chunk of memory block
- **Internal Fragmentation** 
	- Allocating a block of memory that is slightly greater than what the process needs 
	- leads to unused space

#### Fix for External Fragmentation
- Paging
	- Split the memory into pages and frames
	- logical memory -> pages
	- physical memory -> frames
	- page table map pages and frames
	- overhead of this table tho
- Segmentation
	- Split memory into logical divisions of programs - segments
		- like data structures, functions


## Virtual Memory

- Is basically there to give you an illusion of a larger memory space than the system actually has
- Use MMU or software to translate logical address into physical using paging or segmentation
- **Paging**
	- logical address space divided into prefixed size pages 
	- physical into frames
	- page table -> maps
- **Page Faults**
	- When process tries to access data not in physical memory
	- This creates a page handling exception to get the page from disk into RAM
- May slow down performance if used incorrectly

### Demand Paging
- Loads pages into memory only if requested
- Pure demand paging
	- 0 pages in the memory, have to pull from disk for the first time
- Lazy swapper - never swaps a page into memory unless page will be needed
- **Page Replacement**
	- not all pages can fit into physical memory
	- OS must select and remove a unused page to make space for the new page
	- Algos
		- FIFO
		- LRU
		- Optimal Page Replacement OPT

### Thrashing
- When computer's virtual memory resources are overused because of constant paging and page fault being very high
- System spends more time swapping pages than actually executing
- Causes
	- Insufficient physical memory
	- Size of locality (process memory needed) > total memory size
- High page fault rate
- Slow performance
- Solution
	- Working Set Model
		- Keeps track of set of pages currently needed by process and is kept in memory, process is swapped out if cannot to prevent thrashing
	- Priority based Replacement algo